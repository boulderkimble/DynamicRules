{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Dynamic Rules Engine .NET-based rules engine for externally defined rules based on C# LINQ expressions. It currently supports rules in YAML or JSON but could be exanded to support other formats. No releases yet - this project is in pre-alpha. # Global parameters Parameters: - Name: DemoDate Expression: DateTime.Parse(\"2025-08-01\") - Name: IsOldCar Expression: Auto.Age > 10 - Name: HasRecentCollision Expression: Collisions.Any(c => c.VIN == Auto.VIN && c.Date > DemoDate.AddYears(-1)) Rules: - Id: rule_high_risk Condition: IsOldCar && HasRecentCollision Then: '\"VIN: \" + Auto.VIN + \" High Risk\"' The project draws inspiration from Microsoft's JSON Rules Engine , which similarly relies on C#-based rule definitions. The author created it to meet a specific need for an external DSL with rule dependencies (not easily achievable with the Microsoft project). Feature-wise, this engine mirrors many of the capabilites of the Microsoft project, including nested rules, scoped parameters (both local and global), and multiple inputs (concrete or annonyous types). It does not currently support dynamic (expando) inputs. Rules can also be dependent on other rules. A word about YAML & JSON. At current writing this project is YAML centric in terms of documentation, samples, and unit tests. The author developed this project with YAML in mind, so at present JSON is a second class citizen. The project includes a Visual Studio Code extension that will dynamically parse your JSON or YAML rule expressions and hilite any parsing errors. This tool aids in development of rules providing a means to correct any syntax errors before running your rules in the context of your application. A caveat is it can only be used if you are using the rules engine with non-annonymous inputs.","title":"Home"},{"location":"index.html#dynamic-rules-engine","text":".NET-based rules engine for externally defined rules based on C# LINQ expressions. It currently supports rules in YAML or JSON but could be exanded to support other formats. No releases yet - this project is in pre-alpha. # Global parameters Parameters: - Name: DemoDate Expression: DateTime.Parse(\"2025-08-01\") - Name: IsOldCar Expression: Auto.Age > 10 - Name: HasRecentCollision Expression: Collisions.Any(c => c.VIN == Auto.VIN && c.Date > DemoDate.AddYears(-1)) Rules: - Id: rule_high_risk Condition: IsOldCar && HasRecentCollision Then: '\"VIN: \" + Auto.VIN + \" High Risk\"' The project draws inspiration from Microsoft's JSON Rules Engine , which similarly relies on C#-based rule definitions. The author created it to meet a specific need for an external DSL with rule dependencies (not easily achievable with the Microsoft project). Feature-wise, this engine mirrors many of the capabilites of the Microsoft project, including nested rules, scoped parameters (both local and global), and multiple inputs (concrete or annonyous types). It does not currently support dynamic (expando) inputs. Rules can also be dependent on other rules. A word about YAML & JSON. At current writing this project is YAML centric in terms of documentation, samples, and unit tests. The author developed this project with YAML in mind, so at present JSON is a second class citizen. The project includes a Visual Studio Code extension that will dynamically parse your JSON or YAML rule expressions and hilite any parsing errors. This tool aids in development of rules providing a means to correct any syntax errors before running your rules in the context of your application. A caveat is it can only be used if you are using the rules engine with non-annonymous inputs.","title":"Dynamic Rules Engine"},{"location":"about.html","text":"About I wrote this to aid in developing simple rule driven state machines for another project. I decided it might be worth throwing up on github. The initial release is lacking in: Perf testing Optimizations around rule processing (e.g. short circuit evaluation with child rules and OR) \u00a9 2025 Jeff Anderson Licensed under the Apache License, Version 2.0.","title":"About"},{"location":"about.html#about","text":"I wrote this to aid in developing simple rule driven state machines for another project. I decided it might be worth throwing up on github. The initial release is lacking in: Perf testing Optimizations around rule processing (e.g. short circuit evaluation with child rules and OR) \u00a9 2025 Jeff Anderson Licensed under the Apache License, Version 2.0.","title":"About"},{"location":"core.html","text":"RulesEngine.Core Aside from externally defined rules in JSON/YAML, this project exposes a C# rules engine that powers the dynamic rule processiing. The dynamic rule processor builds a set of RulesEngine.Core.Rule rules internally, but the core interface can be used on its own for rules defined in code. If you're looking for a .NET rules engine focused purely on C#, nRules might be the better choice. On the other hand it has a simple fluent interface and might be suitable depending on your requirements. Not much documentation to offer at this time. Here is an example: using RulesEngine.Core; . . var isOldCarRule = new Rule(\"IsOldCar\") .When((rule, parameters) => { var auto = parameters[\"Auto\"] as Auto; return auto != null && auto.Age > 10; }) .Then((rule, parameters, id) => $\"Auto {((Auto)parameters[\"Auto\"]).VIN} is old.\"); var hasRecentCollisionRule = new Rule(\"HasRecentCollision\") .When((rule, parameters) => { var auto = parameters[\"Auto\"] as Auto; if (auto == null) return false; var oneYearAgo = DateTime.Now.AddYears(-1); return auto.CollisionDates.Exists(d => d > oneYearAgo); }) .Then((rule, parameters, id) => $\"Auto {((Auto)parameters[\"Auto\"]).VIN} has a recent collision.\"); var highRiskRule = new Rule(\"HighRisk\") .When((rule, parameters) => parameters.TryGetValue(\"IsOldCar\", out var isOld) && (bool)isOld && parameters.TryGetValue(\"HasRecentCollision\", out var hasRecent) && (bool)hasRecent) .DependsOn(\"IsOldCar\", \"HasRecentCollision\") .Then((rule, parameters, id) => $\"Auto {((Auto)parameters[\"Auto\"]).VIN} is high risk!\"); // Add rules to the engine var engine = new RulesEngineCore(new[] { isOldCarRule, hasRecentCollisionRule, highRiskRule }); // Example input var auto = new Auto { VIN = \"123ABC\", Age = 12, CollisionDates = new List<DateTime> { DateTime.Now.AddMonths(-6) } }; // Run the engine var errors = engine.Run((\"Auto\", auto)); // Output results if (errors.Count == 0) { Console.WriteLine(\"All rules passed!\"); foreach (var artifact in engine.Artifacts) Console.WriteLine($\"Artifact: {artifact.Value}\"); } else { Console.WriteLine(\"Errors:\"); foreach (var error in errors) Console.WriteLine(error); }","title":"RulesEngine.Core"},{"location":"core.html#rulesenginecore","text":"Aside from externally defined rules in JSON/YAML, this project exposes a C# rules engine that powers the dynamic rule processiing. The dynamic rule processor builds a set of RulesEngine.Core.Rule rules internally, but the core interface can be used on its own for rules defined in code. If you're looking for a .NET rules engine focused purely on C#, nRules might be the better choice. On the other hand it has a simple fluent interface and might be suitable depending on your requirements. Not much documentation to offer at this time. Here is an example: using RulesEngine.Core; . . var isOldCarRule = new Rule(\"IsOldCar\") .When((rule, parameters) => { var auto = parameters[\"Auto\"] as Auto; return auto != null && auto.Age > 10; }) .Then((rule, parameters, id) => $\"Auto {((Auto)parameters[\"Auto\"]).VIN} is old.\"); var hasRecentCollisionRule = new Rule(\"HasRecentCollision\") .When((rule, parameters) => { var auto = parameters[\"Auto\"] as Auto; if (auto == null) return false; var oneYearAgo = DateTime.Now.AddYears(-1); return auto.CollisionDates.Exists(d => d > oneYearAgo); }) .Then((rule, parameters, id) => $\"Auto {((Auto)parameters[\"Auto\"]).VIN} has a recent collision.\"); var highRiskRule = new Rule(\"HighRisk\") .When((rule, parameters) => parameters.TryGetValue(\"IsOldCar\", out var isOld) && (bool)isOld && parameters.TryGetValue(\"HasRecentCollision\", out var hasRecent) && (bool)hasRecent) .DependsOn(\"IsOldCar\", \"HasRecentCollision\") .Then((rule, parameters, id) => $\"Auto {((Auto)parameters[\"Auto\"]).VIN} is high risk!\"); // Add rules to the engine var engine = new RulesEngineCore(new[] { isOldCarRule, hasRecentCollisionRule, highRiskRule }); // Example input var auto = new Auto { VIN = \"123ABC\", Age = 12, CollisionDates = new List<DateTime> { DateTime.Now.AddMonths(-6) } }; // Run the engine var errors = engine.Run((\"Auto\", auto)); // Output results if (errors.Count == 0) { Console.WriteLine(\"All rules passed!\"); foreach (var artifact in engine.Artifacts) Console.WriteLine($\"Artifact: {artifact.Value}\"); } else { Console.WriteLine(\"Errors:\"); foreach (var error in errors) Console.WriteLine(error); }","title":"RulesEngine.Core"},{"location":"definingrules.html","text":"Defining Rules # Global parameters Parameters: - Name: DemoDate Expression: DateTime.Now - Name: IsOldCar Expression: Auto.Age > 10 - Name: HasRecentCollision Expression: Collisions.Any(c => c.VIN == Auto.VIN && c.Date > DemoDate.AddYears(-1)) Rules: - Id: rule_low_risk # Note expressions with boolean ! must be included in quotes because it's a reserved tag in YAML Condition: \"!IsOldCar && !HasRecentCollision\" - Id: rule_high_risk Condition: IsOldCar && HasRecentCollision Then: '\"VIN: \" + Auto.VIN + \" High Risk\"' - Id: rule_requires_high_risk DependsOn: [rule_high_risk] Condition: true Then: '\"This rule only runs if rule_high_risk succeeds.\"' Rules Anatomy Dynamic Rules are defined by the object definitions in RulesEngine.Dynamic/Models. A set of YAML or JSON rules is simply a serialization of the DynamicRules C# type: public class DynamicRules { public virtual List<DynamicRuleParameter> Parameters { get; set; } = []; public virtual List<DynamicRule> Rules { get; set; } = []; } Let's review each feature with YAML. Parameters -> (Name, Expression) Global parameters are in scope by all rules and sub-rules. These must be at the top of your rule definitions. Name identifies the parameter. Expression is the C# that the parameter evaulates to. Use the name to refer to the parameter in other expressions. Parameters: - Name: IsOldCar Expression: Auto.Age > 10 - Name: HasRecentCollision Expression: Auto.CollisionDates.Any(d => d > DemoDate.AddYears(-1)) Rules -> (Id, Condition, Then, Parameters, DependsOn, Operator, Rules) Id Unique name of rule Condition C# expression that evaluates to a boolean Then C# expression that evaluates to an object added to an artifact if Condition is satisfied. Note the rules engine always generates an artifact for a succussful rule and artifacts can be accessed from code. The Then expression only adds an object to the artifact. See Using Rules for details. Rules: - Id: rule_high_risk Condition: IsOldCar && HasRecentCollision Then: '\"High Risk: VIN \" + Auto.VIN' - Id: rule_low_risk Condition: \"!IsOldCar && !HasRecentCollision\" Then: \"RiskUtils.FlagLowRisk(Auto.Make, Auto.Age)\" Parameters -> (Name, Expression) Rule scoped parameters. Name should be unique for the given rule. If it matches a global parameter, it overrides the global value. - Id: rule_critical_risk Parameters: - Name: RecentCollisionCount Expression: Auto.CollisionDates.Count(d => d > DemoDate.AddYears(-1)) Condition: \"!IsOldCar && HasRecentCollision\" Then: '\"Critical Review Needed: VIN:\" + Auto.VIN + \" Make:\" + Auto.Make + \" - Recent Collisions: \" + RecentCollisionCount' DependsOn Value is an array of rule IDs that must all evaluate to true before this rule is evaluated. Rule IDs can reference other rules or sub-rules (including those from the same or different rule groups). The rules engine will throw an exception if a circular dependency is detected. - Id: rule_high_risk_toyota DependsOn: [rule_high_risk] Condition: Auto.Make == \"Toyota\" Then: '\"This rule only runs if Toyota and rule_high_risk succeeds.\"' Rules Subrules are nested rules within a parent rule. By default, all subrules must evaluate to true for the parent rule to succeed. Rules: - Id: main_rule Rules: - Id: sub_rule_1 You can control how subrules are combined by specifying the optional Operator parameter, which accepts 'AND' (default) or 'OR': Rules: - Id: main_rule Operator: OR Rules: - Id: sub_rule_1 - Id: sub_rule_2","title":"Defining Rules"},{"location":"definingrules.html#defining-rules","text":"# Global parameters Parameters: - Name: DemoDate Expression: DateTime.Now - Name: IsOldCar Expression: Auto.Age > 10 - Name: HasRecentCollision Expression: Collisions.Any(c => c.VIN == Auto.VIN && c.Date > DemoDate.AddYears(-1)) Rules: - Id: rule_low_risk # Note expressions with boolean ! must be included in quotes because it's a reserved tag in YAML Condition: \"!IsOldCar && !HasRecentCollision\" - Id: rule_high_risk Condition: IsOldCar && HasRecentCollision Then: '\"VIN: \" + Auto.VIN + \" High Risk\"' - Id: rule_requires_high_risk DependsOn: [rule_high_risk] Condition: true Then: '\"This rule only runs if rule_high_risk succeeds.\"'","title":"Defining Rules"},{"location":"definingrules.html#rules-anatomy","text":"Dynamic Rules are defined by the object definitions in RulesEngine.Dynamic/Models. A set of YAML or JSON rules is simply a serialization of the DynamicRules C# type: public class DynamicRules { public virtual List<DynamicRuleParameter> Parameters { get; set; } = []; public virtual List<DynamicRule> Rules { get; set; } = []; } Let's review each feature with YAML.","title":"Rules Anatomy"},{"location":"definingrules.html#parameters-name-expression","text":"Global parameters are in scope by all rules and sub-rules. These must be at the top of your rule definitions. Name identifies the parameter. Expression is the C# that the parameter evaulates to. Use the name to refer to the parameter in other expressions. Parameters: - Name: IsOldCar Expression: Auto.Age > 10 - Name: HasRecentCollision Expression: Auto.CollisionDates.Any(d => d > DemoDate.AddYears(-1))","title":"Parameters -&gt; (Name, Expression)"},{"location":"definingrules.html#rules-id-condition-then-parameters-dependson-operator-rules","text":"","title":"Rules -&gt; (Id, Condition, Then, Parameters, DependsOn, Operator, Rules)"},{"location":"definingrules.html#id","text":"Unique name of rule","title":"Id"},{"location":"definingrules.html#condition","text":"C# expression that evaluates to a boolean","title":"Condition"},{"location":"definingrules.html#then","text":"C# expression that evaluates to an object added to an artifact if Condition is satisfied. Note the rules engine always generates an artifact for a succussful rule and artifacts can be accessed from code. The Then expression only adds an object to the artifact. See Using Rules for details. Rules: - Id: rule_high_risk Condition: IsOldCar && HasRecentCollision Then: '\"High Risk: VIN \" + Auto.VIN' - Id: rule_low_risk Condition: \"!IsOldCar && !HasRecentCollision\" Then: \"RiskUtils.FlagLowRisk(Auto.Make, Auto.Age)\"","title":"Then"},{"location":"definingrules.html#parameters-name-expression_1","text":"Rule scoped parameters. Name should be unique for the given rule. If it matches a global parameter, it overrides the global value. - Id: rule_critical_risk Parameters: - Name: RecentCollisionCount Expression: Auto.CollisionDates.Count(d => d > DemoDate.AddYears(-1)) Condition: \"!IsOldCar && HasRecentCollision\" Then: '\"Critical Review Needed: VIN:\" + Auto.VIN + \" Make:\" + Auto.Make + \" - Recent Collisions: \" + RecentCollisionCount'","title":"Parameters -&gt; (Name, Expression)"},{"location":"definingrules.html#dependson","text":"Value is an array of rule IDs that must all evaluate to true before this rule is evaluated. Rule IDs can reference other rules or sub-rules (including those from the same or different rule groups). The rules engine will throw an exception if a circular dependency is detected. - Id: rule_high_risk_toyota DependsOn: [rule_high_risk] Condition: Auto.Make == \"Toyota\" Then: '\"This rule only runs if Toyota and rule_high_risk succeeds.\"'","title":"DependsOn"},{"location":"definingrules.html#rules","text":"Subrules are nested rules within a parent rule. By default, all subrules must evaluate to true for the parent rule to succeed. Rules: - Id: main_rule Rules: - Id: sub_rule_1 You can control how subrules are combined by specifying the optional Operator parameter, which accepts 'AND' (default) or 'OR': Rules: - Id: main_rule Operator: OR Rules: - Id: sub_rule_1 - Id: sub_rule_2","title":"Rules"},{"location":"example.html","text":"Example See the examples folder for more examples. # Global parameters Parameters: # So that this demo will always run the same results from our testdata.json file, we set a fixed date. # In a real-world scenario, you would use DateTime.Now or similar. - Name: DemoDate Expression: DateTime.Parse(\"2025-08-01\") - Name: IsOldCar Expression: Auto.Age > 10 - Name: HasRecentCollision Expression: Collisions.Any(c => c.VIN == Auto.VIN && c.Date > DemoDate.AddYears(-1)) Rules: - Id: rule_high_risk Condition: IsOldCar && HasRecentCollision Then: '\"VIN: \" + Auto.VIN + \" High Risk\"' -------------------------------------------- [DynamicLinqType] public class CarLotContext : DbContext { public DbSet<Auto> Autos { get; set; } public DbSet<Collision> Collisions { get; set; } public CarLotContext(DbContextOptions<CarLotContext> options) : base(options) { } } var options = new DbContextOptionsBuilder<CarLotContext>() .UseSqlite(\"Data Source=TestDb.sqlite\") .Options; using var context = new CarLotContext(options); context.Database.EnsureCreated(); if (!context.Autos.Any()) { var auto1 = new Auto { VIN = \"1A4AABBC5501999\", Make = \"Toyota\", Age = 12 }; var auto2 = new Auto { VIN = \"2B3CA4CD5GH123456\", Make = \"Honda\", Age = 5 }; context.Autos.AddRange(auto1, auto2); context.Collisions.AddRange( new Collision { VIN = auto1.VIN, Date = new DateTime(2025, 9, 1) }, new Collision { VIN = auto1.VIN, Date = new DateTime(2024, 8, 15) }, new Collision { VIN = auto2.VIN, Date = new DateTime(2025, 1, 10) }, new Collision { VIN = auto2.VIN, Date = new DateTime(2022, 1, 10) } ); } context.SaveChanges(); var rulesLoader = new RulesEngineLoader(); var rules = rulesLoader.LoadRulesFromYaml(new FileInfo(\"rules_sample1.yaml\")); var processor = new DynamicRuleProcessor(rules); processor.CoreEngine.ArtifactAdded += (artifact) => { Console.WriteLine($\"Rule succeeded and artifact added for Rule: {artifact.Id}\"); if (artifact.Value != null) { Console.WriteLine($\"Artifact Object: {artifact.Value}\\n\"); } }; foreach (var auto in context.Autos) { processor.CoreEngine.Run( (\"Auto\", auto), (\"Collisions\", context.Collisions) ); }","title":"Example"},{"location":"example.html#example","text":"See the examples folder for more examples. # Global parameters Parameters: # So that this demo will always run the same results from our testdata.json file, we set a fixed date. # In a real-world scenario, you would use DateTime.Now or similar. - Name: DemoDate Expression: DateTime.Parse(\"2025-08-01\") - Name: IsOldCar Expression: Auto.Age > 10 - Name: HasRecentCollision Expression: Collisions.Any(c => c.VIN == Auto.VIN && c.Date > DemoDate.AddYears(-1)) Rules: - Id: rule_high_risk Condition: IsOldCar && HasRecentCollision Then: '\"VIN: \" + Auto.VIN + \" High Risk\"' -------------------------------------------- [DynamicLinqType] public class CarLotContext : DbContext { public DbSet<Auto> Autos { get; set; } public DbSet<Collision> Collisions { get; set; } public CarLotContext(DbContextOptions<CarLotContext> options) : base(options) { } } var options = new DbContextOptionsBuilder<CarLotContext>() .UseSqlite(\"Data Source=TestDb.sqlite\") .Options; using var context = new CarLotContext(options); context.Database.EnsureCreated(); if (!context.Autos.Any()) { var auto1 = new Auto { VIN = \"1A4AABBC5501999\", Make = \"Toyota\", Age = 12 }; var auto2 = new Auto { VIN = \"2B3CA4CD5GH123456\", Make = \"Honda\", Age = 5 }; context.Autos.AddRange(auto1, auto2); context.Collisions.AddRange( new Collision { VIN = auto1.VIN, Date = new DateTime(2025, 9, 1) }, new Collision { VIN = auto1.VIN, Date = new DateTime(2024, 8, 15) }, new Collision { VIN = auto2.VIN, Date = new DateTime(2025, 1, 10) }, new Collision { VIN = auto2.VIN, Date = new DateTime(2022, 1, 10) } ); } context.SaveChanges(); var rulesLoader = new RulesEngineLoader(); var rules = rulesLoader.LoadRulesFromYaml(new FileInfo(\"rules_sample1.yaml\")); var processor = new DynamicRuleProcessor(rules); processor.CoreEngine.ArtifactAdded += (artifact) => { Console.WriteLine($\"Rule succeeded and artifact added for Rule: {artifact.Id}\"); if (artifact.Value != null) { Console.WriteLine($\"Artifact Object: {artifact.Value}\\n\"); } }; foreach (var auto in context.Autos) { processor.CoreEngine.Run( (\"Auto\", auto), (\"Collisions\", context.Collisions) ); }","title":"Example"},{"location":"expressionrules.html","text":"Expression \"Rules of the Road\" Dynamic Rules uses zzzproject's Dynamic Linq library to parse C# expressions into expression trees. There are some particular abilities and limitations to be aware of. Expressions with 'new' In Then or parameter expressions, you cannot use new to produce a typed object - instead use a static utility class. Use: Then: RiskAssessment.Create(Auto.VIN, \"High Risk\") instead of: Then: new RiskAssessment(Auto.VIN, \"High Risk\") You need to be mindful of this when using primitive types like DateTime. So istead of: Expression: new System.DateTime(2025, 8, 1) use: Expression: DateTime.Parse(\"2025-08-01\") However new can be used to return an annonymous object as long as (1) no labels specified and (2) no object initializers the parser can't infer the type from. In practical terms that means rule input object parameters, primitive .NET types, and types you've declared with the [DynamicLinqType] attribute. Then: \"new { Auto.Make, Auto.Year }\" Anonymous Types & Inputs Inputs can be annoymous types (with or without labels). For annonymous inputs you must use the core engine API's (Run(), RunAsync()) that take a dictionary or name value pairs as input because names must be specified matching your YAML/JSON epxressions. The Run() variants wich accept just an enumation of objects will default the paramter names from the type names (which won't be usable in your rule expressions). Additionally the VS Code extension won't be able to parse and report errors if your code leverages annomyous inputs. String Interpolation C# sting interpolation is not supported in an expression. Data Modification In a rule expression, you can project (select, transform, or create new objects/values from) the input data, but you cannot modify the original input objects or their properties. Allowed: Then: \"Auto.Make\" Not Allowed: Then: \"Auto.Age = 20\"","title":"Expression \"Rules of the Road\""},{"location":"expressionrules.html#expression-rules-of-the-road","text":"Dynamic Rules uses zzzproject's Dynamic Linq library to parse C# expressions into expression trees. There are some particular abilities and limitations to be aware of.","title":"Expression \"Rules of the Road\""},{"location":"expressionrules.html#expressions-with-new","text":"In Then or parameter expressions, you cannot use new to produce a typed object - instead use a static utility class. Use: Then: RiskAssessment.Create(Auto.VIN, \"High Risk\") instead of: Then: new RiskAssessment(Auto.VIN, \"High Risk\") You need to be mindful of this when using primitive types like DateTime. So istead of: Expression: new System.DateTime(2025, 8, 1) use: Expression: DateTime.Parse(\"2025-08-01\") However new can be used to return an annonymous object as long as (1) no labels specified and (2) no object initializers the parser can't infer the type from. In practical terms that means rule input object parameters, primitive .NET types, and types you've declared with the [DynamicLinqType] attribute. Then: \"new { Auto.Make, Auto.Year }\"","title":"Expressions with 'new'"},{"location":"expressionrules.html#anonymous-types-inputs","text":"Inputs can be annoymous types (with or without labels). For annonymous inputs you must use the core engine API's (Run(), RunAsync()) that take a dictionary or name value pairs as input because names must be specified matching your YAML/JSON epxressions. The Run() variants wich accept just an enumation of objects will default the paramter names from the type names (which won't be usable in your rule expressions). Additionally the VS Code extension won't be able to parse and report errors if your code leverages annomyous inputs.","title":"Anonymous Types &amp; Inputs"},{"location":"expressionrules.html#string-interpolation","text":"C# sting interpolation is not supported in an expression.","title":"String Interpolation"},{"location":"expressionrules.html#data-modification","text":"In a rule expression, you can project (select, transform, or create new objects/values from) the input data, but you cannot modify the original input objects or their properties. Allowed: Then: \"Auto.Make\" Not Allowed: Then: \"Auto.Age = 20\"","title":"Data Modification"},{"location":"extension.html","text":"Visual Studio Code Rule Editing Extension To use, configure the extension to load one or more assemblies containing objects marked with specific attributes to tell the extension parser about your rule inputs and parameter types. { \"rulevalidator.assemblyPaths\": \"C:\\\\YamlValidatorTest\\\\bin\\\\Debug\\\\net8.0\\\\YamlValidatorTest.dll\" \"rulevalidator.fileNamePattern\": \"rules_.*\\\\.(yaml|json)$\" } assemblyPaths (comman delineated) must define assemblies (typically 1) with: Input types defined by a static class marked with the VSExtensionConfig attribute. Apply this attribute to a static class. Implement the following method: public static IEnumerable<(string, Type)> ReturnInputMappings() The method must yield all input parameter names and types used with your rules engine. The order does not matter. Other classes marked with DynamicLinqType . As discussed , this type defines additional types referenced in your rules and it is needed by the rules engine itself as well as the extension. // Note if you don't use the VS extension, you don't need this. [VSExtensionConfig] public static class MyRulesInputMapping { public static IEnumerable<(string? Name, Type? Type)> ReturnInputMapForExtension() { yield return (\"Auto\", typeof(Auto)); yield return (\"Collisions\", typeof(DbSet<Collision>)); } } // These are types referenced by the rules engine typically in parameter expressions // or Then expressions to provide processing utility or define a returned object type. // This is required by both the rules engine as well as the VS code extension. The attribute // is defined in the Dynamic Rules package used by the rules library. [DynamicLinqType] public static class DateUtils { public static int Age(DateTime birthdate) { var today = DateTime.Today; int age = today.Year - birthdate.Year; if (birthdate > today.AddYears(-age)) age--; return age; } } Installing Coming...","title":"VS Extension"},{"location":"extension.html#visual-studio-code-rule-editing-extension","text":"To use, configure the extension to load one or more assemblies containing objects marked with specific attributes to tell the extension parser about your rule inputs and parameter types. { \"rulevalidator.assemblyPaths\": \"C:\\\\YamlValidatorTest\\\\bin\\\\Debug\\\\net8.0\\\\YamlValidatorTest.dll\" \"rulevalidator.fileNamePattern\": \"rules_.*\\\\.(yaml|json)$\" } assemblyPaths (comman delineated) must define assemblies (typically 1) with: Input types defined by a static class marked with the VSExtensionConfig attribute. Apply this attribute to a static class. Implement the following method: public static IEnumerable<(string, Type)> ReturnInputMappings() The method must yield all input parameter names and types used with your rules engine. The order does not matter. Other classes marked with DynamicLinqType . As discussed , this type defines additional types referenced in your rules and it is needed by the rules engine itself as well as the extension. // Note if you don't use the VS extension, you don't need this. [VSExtensionConfig] public static class MyRulesInputMapping { public static IEnumerable<(string? Name, Type? Type)> ReturnInputMapForExtension() { yield return (\"Auto\", typeof(Auto)); yield return (\"Collisions\", typeof(DbSet<Collision>)); } } // These are types referenced by the rules engine typically in parameter expressions // or Then expressions to provide processing utility or define a returned object type. // This is required by both the rules engine as well as the VS code extension. The attribute // is defined in the Dynamic Rules package used by the rules library. [DynamicLinqType] public static class DateUtils { public static int Age(DateTime birthdate) { var today = DateTime.Today; int age = today.Year - birthdate.Year; if (birthdate > today.AddYears(-age)) age--; return age; } }","title":"Visual Studio Code Rule Editing Extension"},{"location":"extension.html#installing","text":"Coming...","title":"Installing"},{"location":"using.html","text":"Using the Library Prerequisites Dynamic Rules & Types The engine must know the names and types of your inputs at runtime. The names must match what you use in your Then and Parameter expressions. These are passed in the context of the Run() call to the rules engine: processor.CoreEngine.Run( (\"Auto\", auto), (\"Collisions\", context.Collisions) ); There are variants of Run that take just an enumeration of objects - no names. Only use these if all of your inputs are user defined types and you use the type name(s) (e.g. \"Auto\") in your rule expressions . Asode from inputs, the rules engine must also know about user defined types used in expressions. These are often utility types with static methods. To define these you must use the DynamicLinqType attribute (defined in the Dynamic LINQ library which this project depends on). [DynamicLinqType] public static class RiskUtils { public static string FlagHighRisk(string make, int age, List<DateTime> collisionDates) { return $\"High risk: {make}, Age: {age}, Collisions: {collisionDates.Count}\"; } public static string FlagLowRisk(string make, int age) { return $\"Low risk: {make}, Age: {age}\"; } public static string FlagReview(string make, List<DateTime> collisionDates) { return $\"Review needed: {make}, Recent collisions: {collisionDates.Count}\"; } public static string FlagCriticalReview(string make, int recentCollisionCount) { return $\"Critical review: {make}, Recent collisions: {recentCollisionCount}\"; } } Parameters: - Name: HasRecentCollision Expression: Collisions.Any(c => c.VIN == Auto.VIN && c.Date > DemoDate.AddYears(-1)) Rules: - Id: rule_low_risk # boolean ! must be included in quotes because it's a reserved tag in YAML Condition: \"!IsOldCar && !HasRecentCollision\" # Call a static method that returns a string. Then: \"RiskUtils.FlagLowRisk(Auto.Make, Auto.Age)\" Finally if you want to use the VS Code extension to edit your rules, you will need to mark input types using an attribute. See VS Code Extension for details. Running Load your rules from YAML or JSON (files or string) var rulesLoader = new RulesEngineLoader(); var rules = rulesLoader.LoadRulesFromYaml(new FileInfo(\"rules_sample1.yaml\")); Create a dynamic rules processor instance. var processor = new DynamicRuleProcessor(rules); Run the rules against your input data. The CoreEngine member of the processor is the core rules engine instance. The processor populates the core engine with dynamically compiled delegates from the rule expressions. In the example below, we're using an entity framework context as the data source, but it could be objects from memory or other sources. foreach (var auto in context.Autos) { processor.CoreEngine.Run( (\"Auto\", auto), (\"Collisions\", context.Collisions) ); } Consume/Process artifacts. Artifacts can be received by an event handler: processor.CoreEngine.ArtifactAdded += (artifact) => { Console.WriteLine($\"Rule succeeded and artifact added for Rule: {artifact.Id}\"); if (artifact.Value != null) { Console.WriteLine($\"Artifact Object: {artifact.Value}\\n\"); } };","title":"Using Rules"},{"location":"using.html#using-the-library","text":"","title":"Using the Library"},{"location":"using.html#prerequisites","text":"","title":"Prerequisites"},{"location":"using.html#dynamic-rules-types","text":"The engine must know the names and types of your inputs at runtime. The names must match what you use in your Then and Parameter expressions. These are passed in the context of the Run() call to the rules engine: processor.CoreEngine.Run( (\"Auto\", auto), (\"Collisions\", context.Collisions) ); There are variants of Run that take just an enumeration of objects - no names. Only use these if all of your inputs are user defined types and you use the type name(s) (e.g. \"Auto\") in your rule expressions . Asode from inputs, the rules engine must also know about user defined types used in expressions. These are often utility types with static methods. To define these you must use the DynamicLinqType attribute (defined in the Dynamic LINQ library which this project depends on). [DynamicLinqType] public static class RiskUtils { public static string FlagHighRisk(string make, int age, List<DateTime> collisionDates) { return $\"High risk: {make}, Age: {age}, Collisions: {collisionDates.Count}\"; } public static string FlagLowRisk(string make, int age) { return $\"Low risk: {make}, Age: {age}\"; } public static string FlagReview(string make, List<DateTime> collisionDates) { return $\"Review needed: {make}, Recent collisions: {collisionDates.Count}\"; } public static string FlagCriticalReview(string make, int recentCollisionCount) { return $\"Critical review: {make}, Recent collisions: {recentCollisionCount}\"; } } Parameters: - Name: HasRecentCollision Expression: Collisions.Any(c => c.VIN == Auto.VIN && c.Date > DemoDate.AddYears(-1)) Rules: - Id: rule_low_risk # boolean ! must be included in quotes because it's a reserved tag in YAML Condition: \"!IsOldCar && !HasRecentCollision\" # Call a static method that returns a string. Then: \"RiskUtils.FlagLowRisk(Auto.Make, Auto.Age)\" Finally if you want to use the VS Code extension to edit your rules, you will need to mark input types using an attribute. See VS Code Extension for details.","title":"Dynamic Rules &amp; Types"},{"location":"using.html#running","text":"Load your rules from YAML or JSON (files or string) var rulesLoader = new RulesEngineLoader(); var rules = rulesLoader.LoadRulesFromYaml(new FileInfo(\"rules_sample1.yaml\")); Create a dynamic rules processor instance. var processor = new DynamicRuleProcessor(rules); Run the rules against your input data. The CoreEngine member of the processor is the core rules engine instance. The processor populates the core engine with dynamically compiled delegates from the rule expressions. In the example below, we're using an entity framework context as the data source, but it could be objects from memory or other sources. foreach (var auto in context.Autos) { processor.CoreEngine.Run( (\"Auto\", auto), (\"Collisions\", context.Collisions) ); } Consume/Process artifacts. Artifacts can be received by an event handler: processor.CoreEngine.ArtifactAdded += (artifact) => { Console.WriteLine($\"Rule succeeded and artifact added for Rule: {artifact.Id}\"); if (artifact.Value != null) { Console.WriteLine($\"Artifact Object: {artifact.Value}\\n\"); } };","title":"Running"}]}